本文档主要书写一些数据结构和算法有关的内容

教程

- 怎么学？https://juejin.cn/post/7255217876365115449?searchId=20230919113658FCFBAE399D57ED702F2E
- 大全：https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings
- 大全：https://github.com/sisterAn/JavaScript-Algorithms
- 复杂度
  - https://zhuanlan.zhihu.com/p/248284657#:~:text=log%E8%A1%A8%E7%A4%BA%E5%AF%B9%E6%95%B0.,%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%9F%9F%E2%80%A6
  - https://cloud.tencent.com/developer/article/1613822
- 原来华为有专门的题库：[华为机试_在线编程_牛客网 (nowcoder.com)](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=37&type=37)
- 算法视频
  - [使用两个栈实现四则表达式的计算_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yC4y1Q7Ws/?spm_id_from=333.788&vd_source=522153461914a766fc002cc8619314e4)
  - [LeetCode 最热门 100 题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Pq4y1j78o/?spm_id_from=333.337.search-card.all.click&vd_source=522153461914a766fc002cc8619314e4)


学习目标

- 学到入门即可，因为js不适合写算法，而且我也没有那么多时间



## 关注点

学习计划

- 6.4日：瞎几把刷题
- ~~6.5日：动态规划~~
- ~~6.6日：栈、队列、哈希表~~
- ~~6.7日：树、dfs、bfs~~
- 6.8日：贪心、分治、排序
- 6.10日：复杂度分析



并不是学不会，而是没有找到好的教程，以及做好训练

怎么学？

- 按专题来刷题，而不是乱刷
- 不要死磕，3分钟没思路就跳过
- 多总结
- 跟大佬，看看他们的思路是怎样的



怎么答题？

- 首先确认题型，看它考你什么内容？
- 梳理一下答题思路
- 以上2步都不会的话，就问ai怎么搞，让它辅助你
  - 模板：说出以下考察的主要内容还有解题思路，代码部分用js解答，
- 还有看看大佬，看看他们是怎么解题的，也可以催化一下你的解题速度



怎么判断这道题可不可以用某个算法解决？

- 



常见的操作

- 查找、遍历、插入、删除、
  - 查找是一切的基础，找不到你做不了其他操作



数据结构
- 线性：数组、链表、栈、队列
- 非线性：树、堆、图、散列表



常见算法

- 查找
- 排序
- 遍历、递归
- 动态
- 贪心
- 分治
   - 二分
- 回溯
- 加密
- 机器学习

复杂度分析

#### 考试

- 字符串、数组、链表、树比较常见
- 图、堆比较少考，不用关注
- 

#### 技巧

学会画图很重要

- 可以用processon来做这件事

如果不知道怎么做

- 首先考虑暴力循环

不是所有情况都需要你去保证

- 有些条件自己会遵守，比如n>=m它是能保证的，所以你不用去校验

很多选择可以问大佬的

- 比如leetcode会员与牛客网会员，你选哪个？

注意临界情况

- 很多时候就是临界情况没对齐，导致出错



获取输入？

- readline()

关注一下输出，看下他们要求的输出是啥？有时候题目感觉不是很明确输出是啥

- 



牛客网坑啊

- 报错看不到第几行，只知道是错误的内容

可以先打印一下你的中间值，看是否有错误

- 不需要全部代码写完才验证

注意他们是怎么获取输出的？

- 场景1：需要你自己修改数据结构，你只需要返回指针，它会自己遍历获取结果
- 场景2：你自己拼接出结果来

关注一下指针的指向

- 是赋值前，还是赋值动作后，搞清楚是在前面还是后面做操作

赋值

- 有些赋值是为了保存
- 有些赋值则是为了更新

注意要提前return的场景

- 比如判断是否为完全二叉树？

做判断的，倾向于返回false

- 因为大概率是不满足条件的

有些是要分阶段完成的

- 比如删除最少出现次数的字符，

可以直接拿值来对比的，就不用循环

- 比如str.includes(item),arr.includes(item)



数组

- 去除最小的几个，可以先排序，后裁剪

有些计数需要从顶向下执行的，比如寻找某个值为3个连续的自然数之和的

- 

有些是需要你了解相应的数据公式才能算的

- 比如计算某个连续自然数之和为指定的整数，那么连续自然数之和的公式为n*(n+1)/2

临界条件后面补，

- 但是要补到上面去

有时候你是要&&与||一起用的

- 比如if(con1&&(con2||con3))

取极值

- 最小值：let min=infinity;
- 最大值：let max=0;

判断不一定是要判断整个元素

- 可以只判断其中一部分

一个函数依赖于全局数据，还要不要把它作为函数的参数？

- 

字符串也可以比较的

- 比如'a'<'b'==true

if里面只有return掉，才算是if、else

- 否则都会执行

字母排序的比较

- 直接调用sort方法即可

从字符串中提取英文单词

```js
str="abc123"
str.match(/[a-z][A-Z]/g).sort().join("") //abc
```



#### 概念

数组子序列：可以不连续，但是要保持数组原始顺序，

注意搞清楚回文的概念：正着读和反着读都一样的就是回文

- 单个字符a是回文，aa也是回文，aba也是



## 坑

- 减法和逗号不要搞错了，比如Math.abs(a-b)，而不是Math.abs(a,b)

概念理解，注意你很多时候对概念的理解有缺失或误解

- 连续自然数之和：并不需要从0开始，而是连续就行

api熟练度

- 平时应该练一下常见的操作api，不然考试的时候可能单词拼不出来

- 

索引问题
- 索引是否拿对了？拿i，还是str[i]，还是j，不要搞错了
- 索引更新是否正确，是否多+1，还是少-1

数据重置的问题
- 比如计数重置、索引重置、数组重置

边界问题

- split要注意一下边界，有时候要比如str="a,b,c,",arr=split(str)
  - 结尾多了个空字符串，记得要pop一下

- 比如输入的数组为空
- 比如没找到结果，也要返回为空
- 

注意0与undefined的有区别

- 不要直接if(!value)，这样就把他俩都等同了，误判
- 用if(value===undefined)

for循环中的是没有缓存的，比如你写了arr.length，

- for(let i=0;i<arr.length;i++)，如果arr元素个数更新了，那么for中的遍历次数会变，最好是先提前用一个变量存下来先



## 常见练习

```js
//Number
// 判断是否为数字，并尝试转换成数字，而且只支持十进制字符串，Number("ff")=NaN
Number(str);
// 判断是否为NaN
isNaN(str)
// 数字转字符串
num.toFixed(1);// 1.45->"1.5"，为啥不能继续保留类型为浮点数？

//Math
//最大
Math.max(num1,num2)
// 绝对值
Math.abs(num1-num2)

// string
// 变大写
str.toUpperCase()
// 判断是否为字母
const code=str.charCodeAt(0)
return (code>=65&&code<=90||code>=97||code<=122)
// 排序
str.sort()
// 判断是否为大写或小写字母，用正则
/[a-z]/.test(str)

// 数组
// 快速构造，填充数据
new Array(len).fill(0)
// 数组清空
arr.length=0
// 数组去重
Array.from(new Set(arr))
// 字符串转数组
Array.from(str),str.split(",")
// 集合转数组
Array.from(set)
// 字符串转数组
Array.from(str)
// 构造二维数组
Array.from({length:len},()=>new Array(len).fill(0))
// 判断元素是否在数组中？数组元素比较少用==,比较多则是用includes，如果只判断部分则是用filter,然后判断数组长度
if(item=='foo'||item=='bar')
if(arr.include(item))
// 数组转字符串
arr.join(",")
arr.toString()
    
// 集合Set
// 数组转set，居然可以保持顺序
new Set(arr)
// set不能直接排序，但是可以转换成数组，再排序
Array.from(set)
// 字符串转set
new Set(str)


// 映射Map
new Map()
```




## 数据结构

你要知道它的数据结构才能知道能做什么操作，不能做什么操作，比如链表就不能做随机访问操作





#### 数组

：字符串也是数组的一种



#### 链表

：通常不用数组实现，所以不能随机访问

常见

- 单链表、双链表、循环链表

关注一下需要几个指针来做这件事

链表



#### 栈

：先进后出

例题

- 计算字符串表达式
- 判断括号序列
  - 把([{先存起来，然后一一匹配，一旦匹配失败就返回false，匹配工程则是弹出



#### 队列

实现方式

- 数组：结合push和shift操作



经典题

- 



#### 哈希表

：一般用对象实现，直接由现成的，不用你实现，你只要会用即可

经典题

- 统计重复出现的字符
  - 用hash表来存储，判断是否出现过，用空间换时间，如果在hash里未找到，则是插入到hash，已找到则是插入到结果集里



#### 树



考题

- 遍历类：一般就考遍历，通过遍历来搜索
  - 计算树的最小、最大深度
  - 树的翻转
  - 判断是否为二叉搜索树
  - bfs：用队列即可完成层次遍历
    - shift一个，push左右两个子树
- 构造类：能构造多少种二叉树，多少种二叉搜索树
  - 计算多少种

分类

- 二叉树

  - 二叉搜索树（也叫排序树）：根节点大于左子树所有节点，小于右子树
    - 场景：高效的查找、排序
    - 特点：它的中序遍历是有序的
  - 平衡二叉树：左右子树的高度差最多为1，而且左右子树也都是
    - 场景：保持操作的效率
  - 完全二叉树：除了最后一层，都被填满了，而且编号是左边先满
    - 场景：
  - 满二叉树：树都被填满了，要么是叶节点，要么有2个子节点
    - 场景：

- 字典树



树的遍历

前序、中序、后序遍历

- 前序是根先，即根左右
- 中序（常见）：左根右
- 后序（常见）：左右根



高度、深度问题？

：我认为要从1开始算，深度和高度的计算起点不同，深度是从根节点开始算，而高度则是从叶节点开始算





#### 图

：由节点和边构成

常见

- 有向图
- 无向图

常见题型

- BFS：



#### 堆

：难度较高，先不用管，一种特殊的树，通常是完全二叉树

使用场景

- 优先队列

常见

- 最小堆：所有的节点都小于或等于它的子节点，根节点的值是最小的

- 最大堆





## 遍历

写法

```js
// 遍历每一个元素
for(let i=0;i<length;i++){
    // 遍历剩余的元素
    for(let j=i;i<length;j++)
}
```





## 递归

关注点

- 终止条件：不然会无限递归
- 问题的拆解：正确的拆解和合并问题
- 边界情况：确保代码能够在各种情况下都能正确运行

递归时候优先考虑参数传递，而不是用返回值

- 一些比较简单的才考虑用返回值，比如计算树的最大深度的





- 













## 动态规划

：把一件事分解多个阶段，通过阶段之间的转移达成最终目标

怎么判断是否能用动态规划解决？

- 

特点

- 有记忆功能

解题思路

```js
定义状态：就是dp[i]，或则还是dp[i][j]代表啥意思
状态初始化：
状态转移方程：对dp[i][j]的值进行修改

```







dp是一个数组，里面存放所有的结果

- 可以存bool，number值



例题

- 最长回文字符串
- 最长子序列
  - dp[i]=max(dp[i],dp[j]+1)




## 贪心

：目标是希望当下采取最优策略，得到全局最优的效果

特点

- 无记忆功能

解题思路

- 排序
- 选择
  - 其实就是写多个if、else
- 更新
  - 比如更新索引





## 分治

：是把大问题，分解成小问题的算法，它的范围更广



#### 二分

：二分是分治的一种

算法模板

- 分解
- 解决
- 合并



## 回溯

：采用的是试错策略，走不通就往回头

解题模板

- 构造树
- 遍历数据
- 不满足条件就回头









## 深度优先遍历DFS

前中后序遍历都是dfs





## 广度优先遍历BFS

层次遍历是一种特殊的bfs

- 当bfs应用在树结构时，他就是一种层次遍历









## 位运算





## 滑动窗口





## 并查集



## 双指针

经典例题

- 接雨水
- 



## 排序算法

：前6种是常用的

- 选择
- 冒泡
- 快速
- 插入
- 归并
- 堆
- 希尔
- 计数
- 桶
- 基数

还有一种特殊的：字典排序

- 'a'<'b'==true
- 如果全部比下来，都相等，那么就是短的排前面



## 数学公式

有些问题需要通过数学公式进行解答，不然很难计算





## 牛客网

输入输出

```js
// 获取输入的字符串：
line = await readline()

//如果是多行，则是用在while里面再调用readline即可，
while(line=await readline()){
    
}

// 如果是空格隔开的，可以用splint，然后再parseInt
let tokens = line.split(' ');
let a = parseInt(tokens[0]);
let b = parseInt(tokens[1]);
```

坑

- 经典题类型：在函数里面执行console.log打印无效



## 复杂度

常见的几种复杂度，有常数阶1，线性阶n，平方阶n^2，指数阶2^n，对数阶logn，线性对数阶nlogn

复杂度一般跟这几个动作联系在一起

- 增（插入）、删、查，没有改



#### 时间复杂度

：表示输入规模的增长，执行时间的增长率

插入动作的时间复杂度跟插入位置有关系

- 头尾都是O(1)
- 中间是O(n)



平均时间复杂度

：计算方式为加权平均

- 比如单链表的插入平均时间复杂度



#### 空间复杂度

：表示输入规模的增长，需要的内存空间的增长率

比时间复杂度

可以试试不同的解法，比如用空间换时间

- 动态规划的，可以
- 





## 问题

为啥要学习算法？

- 面试：会有算法题
- 内功：学会算法后有助于修炼自己的内功，写出高质量的代码

怎么学？

- 循序渐进：先简单后困难
- 侧重广度：按题型来刷
- 学会放弃：如果5分钟没有任何思路，则是放弃，直接看答案

怎样区分线性、非线性数据结构？

- 根据元素之间的组织关系，前一个后一个元素如果是顺序连在一起的，才是顺序，像哈希表就不是

同或、异或的关系

- 同或：相同为1
- 异或：不同为1

怎样设计形参？还有我怎么确定某个参数是要当做形参还是返回值？

是要拆分成一个新的方法来递归？还是用当前方法来递归？

map与object的区别

- map优点
  - 能够保持属性的插入顺序
  - 能够支持非字符串类型的作为key

