

前言：本文主要记录一些js的要点和学习过程中产生的问题

教程

- 函数有关：https://juejin.cn/post/6864378349512065038
- 闭包：https://juejin.cn/post/6937469222251560990
- [事件模型？](https://juejin.cn/post/6844903568462331912)
- js操作style、class：https://juejin.cn/post/6844903822624555016
- [js的常见操作](https://juejin.cn/post/6844904136161361933)（你后面所有的操作都不会超出这个）
- 正则：
- [js面试题](https://juejin.cn/post/6940945178899251230)
- [js面试题下](https://juejin.cn/post/6941194115392634888)
- [闭包](https://juejin.cn/post/6937469222251560990#heading-7)
- [回调函数中的this指向问题](https://juejin.cn/post/6914474760848506887)

## 问题

原型与原型链

什么是原型对象？

：系统在构造函数定义时，自动关联的一个对象，目标是能够为构造函数生成的实例提供一些公共的属性和方法（不过一般值加公共方法）

那构造函数的__proto__得到的是啥

instanceof

：用来判断实例的原型链上是否能找到该类型的原型

规则（原型链应该是从顶层开始往下推，你记住那个原型链的图就行了）

：https://juejin.cn/post/6844904093828251662#heading-18

- 所有对象或实例都有构造函数（如Person），而构造函数的原型又是对象，这些对象的构造函数就是Object

- null是Object原型的原型
- 任意构造函数的原型都是Function原型
  - Person.proto==Function.prototype
  - Object.proto==Function.prototype

prototype与proto的区别

- 两者指向的都是同一个东西，如Person.prototype==p.proto，但是调用它们的人不同，前者是prototype来调用，后者是proto
- prototype表示的是类原型，proto则是对象原型



this的上下文是啥意思？

- 即this的指向

[语句与表达式的区别？](https://segmentfault.com/a/1190000021293978)

- 语句是为了做某个动作，如 let name='zeng'
- 而表达式一定会得出某个值

[箭头函数中this的指向，](https://blog.csdn.net/xu4321083/article/details/79753800)

- 指向外层的作用域的this，本身就是就处在函数里，**对象不算一层作用域**，而且是静态作用域（即定义时的作用域）
- [使用场景](https://zhuanlan.zhihu.com/p/60734960)：
- 箭头函数不适用场景
  - 对象的方法（应为我对象方法就是为了操作属性啊）
  - 动态上下文的回调函数（就是我需要你this指向新的对象了，但是你用回调函数就是固定的this指向了)

this指向会被改变的四个场景

- 通过call、apply、bind、
- 构造函数执行
- 作为方法调用
- 普通函数执行
- 箭头函数的this是改不了的



[终于搞懂复杂是啥玩意了，这tm重在对比啊](https://zhidao.baidu.com/question/314930784.html)

- 比如，搜索的一维数组的搜索操作时间复杂度是O(1)是指你10个元素的数组和10000个元素的数组找一个元素都是一样的耗时
- O(n)则是时间复杂度与你的数据规模有关系，比如1个元素的耗时是t，则100个元素的耗时就是10t了，主要是拿1和括号内的东西做对比
- O(n的平方)则是时间复杂度与你的数据规模有关系，比如10个元素的耗时是t，则100个元素的耗时就是100t了，这算法写的不行啊，哈哈哈



闭包

：为什么叫闭包？因为他封闭了一个环境，环境里面有变量和函数





防抖与节流的区别

- 防抖是回城，每重新触发一次事件，就会重新开始计时，计时到了才会执行动作
  - 实现：闭包+定时器，每次触发事件的时候都清除一下定时器
- 节流则是技能：规定时间内只会执行1次动作，如果某一时刻多次触发，那么只会执行1次，因为会进入技能冷却时
  - 实现：闭包+定时器，每次触发时间时看定时器有没有被初始化，如果没有则是初始化一下，有则啥都不做

